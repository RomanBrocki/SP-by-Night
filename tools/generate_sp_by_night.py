"""
Scenario generator for "Sao Paulo by Night" (Vampire: the Masquerade V5).

This project was originally generated by a larger script. If that script is missing/corrupted,
this file rebuilds the essential generation steps from the on-disk source-of-truth:
- tools/sp_by_night_source.json (entities + background text)
- tools/sp_map_config.json (zones/domains/POIs)
- tools/sp_district_claims.json (district geopolitics: control/claims/disputes/pressures)
- tools/sp_domain_districts.json (domain -> district polygons)
- tools/templates/** (static markdown templates)

Design goal: keep coherence with existing lore. By default we do NOT overwrite files.
Use --overwrite to regenerate outputs.
"""

from __future__ import annotations

import argparse
import json
import re
import shutil
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


ROOT = Path(__file__).resolve().parents[1]


def die(msg: str, code: int = 2) -> None:
    raise SystemExit(f"ERROR: {msg}")


def read_json(path: Path) -> Any:
    return json.loads(path.read_text(encoding="utf-8"))


def write_text(path: Path, text: str, overwrite: bool) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    if path.exists() and not overwrite:
        return
    path.write_text(text, encoding="utf-8")


def copy_file(src: Path, dst: Path, overwrite: bool) -> None:
    dst.parent.mkdir(parents=True, exist_ok=True)
    if dst.exists() and not overwrite:
        return
    shutil.copyfile(src, dst)


def clan_folder(clan: str) -> str:
    # Matches existing folder layout (02_NPCS/<ClanNameWithUnderscores>).
    s = (clan or "Unknown").strip()
    s = s.replace("-", " ").replace("/", " ")
    s = re.sub(r"\s+", "_", s)
    return s


def tier_to_blood_potency(tier: str, clan: str) -> int:
    if (clan or "").lower().startswith("thin"):
        return 0
    t = (tier or "").strip().upper()
    return {"S": 4, "A": 3, "B": 2, "C": 1}.get(t, 1)


def default_mortal_footprint(e: "Entity") -> List[str]:
    clan = (e.clan or "").lower()
    role = (e.role or "").lower()
    sect = (e.sect or "").lower()
    out: List[str] = []

    if "ventrue" in clan:
        out += [
            "Financas e imobiliario (fundos, holdings, locacoes estrategicas).",
            "Influencia em seguranca privada e compliance (controle de acesso, camadas de permissao).",
            "Intermediacao via advogados, consultorias e fixers (apagamento de incidentes).",
            "Relacoes com elites corporativas (eventos, conselhos, patrocinios).",
        ]
    elif "toreador" in clan:
        out += [
            "Arte e midia (curadoria, eventos, reputacao e narrativas).",
            "Cenas noturnas (clubes, galerias, circulos VIP).",
            "Intermediacao social (listas, convites, portas que abrem e fecham).",
        ]
    elif "nosferatu" in clan:
        out += [
            "Infra, dados e rotas (camadas de acesso, 'quem sabe o caminho').",
            "sumicos logisticos (entregas, galpoes, portoes, horarios).",
            "Mercado de informacao (dossies, chantagem, OSINT, vazamentos).",
        ]
    elif "brujah" in clan:
        out += [
            "Movimento de rua e protecao informal (bairro, torcida, sindicato, igreja local).",
            "Crime organizado de baixo perfil (cobranca, seguranca, 'taxa').",
            "mediacao com liderancas comunitarias (favor por favor).",
        ]
    elif "banu" in clan or "haqim" in clan:
        out += [
            "Rede juridica e de investigacao (advocacia, auditoria, pressao oficial).",
            "seguranca e resposta (pessoas que chegam rapido demais).",
            "Controle de risco e rastros (apagar evidencia, reescrever narrativa).",
        ]
    elif "tremere" in clan:
        out += [
            "Academia e laboratorios (pesquisa, bolsas, comites de etica como escudo).",
            "Ocultismo de vitrine (livrarias, palestras, grupos de estudo).",
            "Arquivos e burocracia (quem controla o registro controla a versao).",
        ]
    elif "hecata" in clan:
        out += [
            "Funerarias, cemiterios e logistica de corpo (o que some, some direito).",
            "Cartorios e registros (nome, documento, heranca).",
            "Intermediacao de dividas (boons como tabela, cobranca como ritual).",
        ]
    elif "lasombra" in clan:
        out += [
            "Igrejas, filantropia e bastidores (moral como ferramenta).",
            "Acordos de silencio (testemunha vira devota, nao delatora).",
            "Acesso a 'fundos escuros' (quem paga, some).",
        ]
    elif "ministry" in clan:
        out += [
            "Cultos urbanos e recrutamento (influencia, vicio, promessa).",
            "espacos de festa e culto (boate, after, estudio, 'retiro').",
            "extorsao suave (a pessoa acha que escolheu).",
        ]
    elif "malkavian" in clan:
        out += [
            "Rumor e previsao (padroes sociais, coincidencias, mensagens).",
            "intervencoes pequenas com impacto grande (um telefonema muda tudo).",
        ]
    elif "gangrel" in clan:
        out += [
            "Rotas de carga, trilhas e fronteiras (batedores, escoltas, sumicos).",
            "protecao de borda (onde a cidade vira mata, alguem manda).",
        ]
    else:
        out += [
            "Rede comunitaria e de bairro (associacoes, coletivos, liderancas locais).",
            "Mercado cinza e documentos (identidades descartaveis, sumico digital).",
            "Acesso informal a rotas e portas (segurancas, porteiros, motoristas).",
        ]

    if "principe" in role or "senescal" in role or "xerife" in role:
        out.append("Influencia em politica e protocolo (cadeia de comando, etiqueta, punicao).")
    if "anarch" in sect or "baron" in role or "baronesa" in role:
        out.append("Controle territorial por lealdade (protecao, punicao, comunidade).")

    # Keep short and readable (map panel uses up to 6).
    return out[:6]


def tone_for_narration(e: "Entity") -> str:
    clan = (e.clan or "").strip().lower()
    role = (e.role or "").strip()
    name = e.display_name or "Esta pessoa"

    if "ventrue" in clan:
        return (
            f"{name} pressiona por acesso e protocolo. Em cena isso e concreto: a portaria barra seu nome, "
            "o elevador entra em 'manutencao', o seguranca pede documento, o evento vira 'somente convidados', "
            "e o advogado certo aparece para oferecer uma saida que ja vem com custo. "
            "Nao e magia: e cadeia de comando, dinheiro, medo e papel assinado."
        )
    if "nosferatu" in clan:
        return (
            f"{name} opera por infraestrutura e informacao. Em cena: uma camera cai por 90 segundos, "
            "um portao lateral esta destrancado, um caminho pelo subsolo evita blitz, "
            "e uma porta de servico vira passagem porque alguem 'ja combinou'. "
            "O custo aparece depois, como cobranca de informacao ou favor."
        )
    if "tremere" in clan:
        return (
            f"{name} e metodo e contingencia. Em cena: tudo vira procedimento (selos, verificacoes, contramedidas), "
            "e qualquer improviso vira risco registrado. Quem quebra a regra descobre que a regra tem dentes."
        )
    if "toreador" in clan:
        return (
            f"{name} domina sala e narrativa. Em cena: um elogio vira rotulo, um boato vira pauta, "
            "e uma foto fora de contexto vira sentenca social. Se a mesa 'vira assunto', "
            "a consequencia vem como portas fechadas e convites cancelados."
        )
    if "banu" in clan or "haqim" in clan:
        return (
            f"{name} faz a conversa virar procedimento. Em cena: perguntas parecem casuais, mas montam um quadro; "
            "contradicoes viram chantagem; e a punicao vem como 'precedente' (multa, restricao, aviso do Xerifado). "
            "Nao e teatral: e disciplina e rastreio."
        )
    if "lasombra" in clan:
        return (
            f"{name} usa culpa, segredo e protecao como moeda. Em cena: alguem oferece 'refugio' e pede confissao; "
            "um erro de Mascara vira 'pecado' a ser pago; e a protecao vem com obediencia e silencio."
        )
    if "malkavian" in clan:
        return (
            f"{name} e percepcao que incomoda. Em cena: padroes aparecem onde ninguem queria ver, "
            "e uma frase fora de lugar desmonta a mascara de uma sala inteira."
        )
    if "hecata" in clan:
        return (
            f"{name} e taxa e passagem. Em cena: portas se abrem, mas cada abertura vem com registro, "
            "um recibo social e uma cobranca futura. O morto nao esquece, e eles tambem nao."
        )
    if "gangrel" in clan:
        return (
            f"{name} e fronteira viva. Em cena: rotas, bordas e lugares que a cidade finge que nao existem "
            "ganham dono por presenca fisica. Aqui promessa vale menos que demonstracao."
        )
    if "ministry" in clan:
        return (
            f"{name} e isca e culto. Em cena: a oferta parece escolha, o vicio parece cura, "
            "e quando voce aceita, ja esta dentro do circulo."
        )
    if "tzimisce" in clan:
        return (
            f"{name} e hospitalidade predatoria. Em cena: abrigo vem com clausula, "
            "e a casa (ou o corpo) lembra quem e o dono."
        )
    if "ravnos" in clan:
        return (
            f"{name} e deslocamento e golpe. Em cena: verdade vira truque, truque vira rota, "
            "e ninguem sabe quem esta levando quem."
        )
    if "thin" in clan:
        return (
            f"{name} e sobrevivencia em publico. Em cena: tudo e improviso, cadeia curta de favores, "
            "e a Mascarada e uma parede rachada que ainda fica de pe."
        )
    if "caitiff" in clan:
        return (
            f"{name} e utilidade perigosa. Em cena: alguem tenta usar, alguem tenta culpar, "
            "e a pessoa aprende a viver entre martelo e bigorna."
        )

    return (
        f"{name} e presenca. Em cena: as conversas mudam de assunto, celulares somem do tampo da mesa, "
        "e gente que nao devia obedecer passa a obedecer, por reputacao e medo."
    )


def tone_for_non_kindred(e: "Entity") -> str:
    name = e.display_name or "Esta pessoa"
    role = (e.role or "").lower()
    area = e.domain or "Sao Paulo"

    if "motorista" in role:
        return (
            f"{name} e rota e placa. Em cena: ele(a) sabe qual entrada nao tem camera, "
            "qual horario evita blitz, e como trocar de carro sem deixar padrao. "
            f"Area operacional: {area}."
        )
    if "seguranca" in role or "portaria" in role:
        return (
            f"{name} e porta e permissao. Em cena: ele(a) decide quem entra, quem espera, "
            "qual elevador funciona, e qual justificativa o predio aceita. "
            f"Area operacional: {area}."
        )
    if "fotogra" in role or "camera" in role or "cinegraf" in role:
        return (
            f"{name} e imagem e prova. Em cena: ele(a) sabe o que cortar, o que guardar, "
            "e o que vazar para destruir reputacao. "
            f"Area operacional: {area}."
        )
    if "recepc" in role or "lista" in role or "elysium" in role:
        return (
            f"{name} e etiqueta aplicada. Em cena: ele(a) controla lista, convite e desculpa; "
            "sabe quem pode ficar e quem precisa ir embora sem escandalo. "
            f"Area operacional: {area}."
        )
    if "medic" in role or "socorro" in role or "triagem" in role or "terapeuta" in role:
        return (
            f"{name} e cuidado sob pressao. Em cena: ele(a) resolve ferida e colapso sem chamar hospital, "
            "e sabe quais profissionais mortais comprados aceitam 'casos estranhos'. "
            f"Area operacional: {area}."
        )

    return (
        f"{name} e a ponte pratica entre o tabuleiro cainita e o mundo mortal. Em cena: "
        "ele(a) tem acesso a um lugar, uma pessoa ou um documento que vira moeda de favor. "
        f"Area operacional: {area}."
    )


@dataclass(frozen=True)
class Entity:
    id: str
    display_name: str
    file_stem: str
    kind: str  # kindred/ghoul/mortal/...
    clan: str
    sect: str
    role: str
    domain: str
    apparent_age: Optional[int]
    embrace_year: Optional[int]
    born_year: Optional[int]
    sire: str
    childer: List[str]
    disciplines_top3: str
    signature_style: str
    touchstones: List[str]
    scene_hooks: List[str]
    ambition: str
    fear: str
    secret: str
    false_rumor: str
    dangerous_truth: str
    tier: str
    links: List[Dict[str, Any]]
    full_sheet: str
    portrait_prompt: str
    appearance_explicit: str
    coteries: List[str]

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Entity":
        fs = d.get("full_sheet") or ""
        if not isinstance(fs, str):
            # Backward-compatible: allow structured sheets in source JSON.
            fs = json.dumps(fs, ensure_ascii=False, indent=2)
        return Entity(
            id=d.get("id", ""),
            display_name=d.get("display_name") or d.get("name") or "",
            file_stem=d.get("file_stem") or "",
            kind=d.get("kind") or "kindred",
            clan=d.get("clan") or "",
            sect=d.get("sect") or "",
            role=d.get("role") or "",
            domain=d.get("domain") or "",
            apparent_age=d.get("apparent_age"),
            embrace_year=d.get("embrace_year"),
            born_year=d.get("born_year"),
            sire=d.get("sire") or "",
            childer=list(d.get("childer") or []),
            disciplines_top3=d.get("disciplines_top3") or "",
            signature_style=d.get("signature_style") or "",
            touchstones=list(d.get("touchstones") or []),
            scene_hooks=list(d.get("scene_hooks") or []),
            ambition=d.get("ambition") or "",
            fear=d.get("fear") or "",
            secret=d.get("secret") or "",
            false_rumor=d.get("false_rumor") or "",
            dangerous_truth=d.get("dangerous_truth") or "",
            tier=d.get("tier") or "",
            links=list(d.get("links") or []),
            full_sheet=fs,
            portrait_prompt=d.get("portrait_prompt") or "",
            appearance_explicit=d.get("appearance_explicit") or "",
            coteries=list(d.get("coteries") or []),
        )


def load_entities() -> List[Entity]:
    src_path = ROOT / "tools" / "sp_by_night_source.json"
    if not src_path.exists():
        die("missing tools/sp_by_night_source.json")
    src = read_json(src_path)
    ents = [Entity.from_dict(x) for x in (src.get("entities") or [])]
    return ents


def load_coteries_index() -> Dict[str, Dict[str, Any]]:
    """Load coteries/associacoes definitions from tools/sp_by_night_source.json."""
    src_path = ROOT / "tools" / "sp_by_night_source.json"
    if not src_path.exists():
        return {}
    src = read_json(src_path)
    out: Dict[str, Dict[str, Any]] = {}
    for c in (src.get("coteries") or []):
        if not isinstance(c, dict):
            continue
        cid = (c.get("id") or "").strip()
        if not cid:
            continue
        out[cid] = c
    return out


def apply_templates(overwrite: bool) -> None:
    tpl_root = ROOT / "tools" / "templates"
    if not tpl_root.exists():
        return
    for p in tpl_root.rglob("*"):
        if p.is_dir():
            continue
        rel = p.relative_to(tpl_root)
        dst = ROOT / rel
        copy_file(p, dst, overwrite=overwrite)


def entity_dir_and_prefix(e: Entity) -> Tuple[Path, str]:
    if e.kind == "kindred":
        d = ROOT / "02_NPCS" / clan_folder(e.clan)
        return d, "NPC"
    if e.kind == "ghoul":
        d = ROOT / "03_SERVOS_E_CONTATOS" / "ghouls"
        return d, "Ghoul"
    if e.kind == "mortal":
        d = ROOT / "03_SERVOS_E_CONTATOS" / "mortais_influentes"
        return d, "Mortal"
    d = ROOT / "03_SERVOS_E_CONTATOS" / "cainicais_outros"
    return d, "Outro"


def format_links_line(entities_by_id: Dict[str, Entity], link: Dict[str, Any]) -> str:
    to_id = link.get("to", "")
    target = entities_by_id.get(to_id)
    name = (target.display_name if target else to_id) or to_id
    kind = (target.kind if target else "").strip()
    role = (target.role if target else "").strip()
    ltype = (link.get("type") or "").strip()
    note = (link.get("note") or "").strip()
    bits = []
    if kind:
        bits.append(kind)
    if role:
        bits.append(role)
    mid = "; ".join(bits) if bits else ""
    tail = ""
    if note:
        tail = f": {note}"
    if mid:
        return f"- {name} ({mid}) [{ltype}]{tail}".rstrip()
    return f"- {name} [{ltype}]{tail}".rstrip()


def write_entity_files(entities: List[Entity], overwrite: bool) -> None:
    by_id = {e.id: e for e in entities}
    coteries_by_id = load_coteries_index()
    servants_by_master: Dict[str, List[Entity]] = defaultdict(list)
    for x in entities:
        if x.kind not in ("ghoul", "mortal"):
            continue
        for l in (x.links or []):
            if (l.get("type") == "servant") and l.get("to"):
                servants_by_master[str(l["to"])].append(x)

    def coteries_labels(e: Entity) -> List[str]:
        out = []
        for cid in (e.coteries or []):
            meta = coteries_by_id.get(cid) or {}
            nm = (meta.get("name") or cid).strip()
            if nm:
                out.append(nm)
        return out

    for e in entities:
        out_dir, _ = entity_dir_and_prefix(e)
        stem = e.file_stem or re.sub(r"[^A-Za-z0-9_]+", "_", e.display_name).strip("_") or e.id

        # Resumo
        if e.kind == "kindred":
            bp = tier_to_blood_potency(e.tier, e.clan)
            ficha = []
            ficha.append(f"Nome / Alcunha: {e.display_name} / {e.role}".strip())
            ficha.append(f"Cla: {e.clan} | Seita: {e.sect}".strip())
            ficha.append(
                "Idade aparente: {age} | Abraco: {embrace} | Potencia do Sangue {bp}".format(
                    age=(e.apparent_age if e.apparent_age is not None else "-"),
                    embrace=(e.embrace_year if e.embrace_year is not None else "-"),
                    bp=bp,
                )
            )
            ficha.append(f"Dominio / area principal: {e.domain or '-'}")
            ficha.append(f"Disciplinas (top 3): {e.disciplines_top3 or '-'}")
            ficha.append(f"Assinatura / estilo: {e.signature_style or '-'}")
            labs = coteries_labels(e)
            ficha.append("Coteries/associacoes (grupo e rede):")
            if labs:
                for nm in labs[:6]:
                    ficha.append(f"- {nm}")
            else:
                ficha.append("- (Sem grupo formal registrado)")
            servants = servants_by_master.get(e.id) or []
            ficha.append(f"Ghouls/servos diretos: {len(servants)}")
            if servants:
                for sx in sorted(servants, key=lambda z: z.display_name or "")[:6]:
                    ficha.append(f"- {sx.display_name} ({sx.role or 'ghoul'})")
            ficha.append("Touchstones/Conviccoes (resumo):")
            if e.touchstones:
                for t in e.touchstones[:6]:
                    ficha.append(f"- {t}")
            else:
                ficha.append("- (Nao definido)")
            ficha.append("Ganchos de cena:")
            if e.scene_hooks:
                for h in e.scene_hooks[:6]:
                    ficha.append(f"- {h}")
            else:
                ficha.append("- (Nao definido)")
            ficha.append("Atuacao mortal (explicita):")
            for m in default_mortal_footprint(e):
                ficha.append(f"- {m}")
            ficha.append("Servos/contatos notaveis (entrada rapida):")
            if e.links:
                for l in e.links[:10]:
                    ficha.append(format_links_line(by_id, l))
            else:
                ficha.append("- (Sem conexoes registradas)")

            write_text(out_dir / f"{stem}_ficha_resumida.txt", "\n".join(ficha).rstrip() + "\n", overwrite=overwrite)

            # Historia
            hist = []
            hist.append(e.display_name)
            hist.append("")
            hist.append("Perfil:")
            hist.append(f"- Cla: {e.clan} | Seita: {e.sect} | Funcao: {e.role}")
            hist.append(f"- Dominio: {e.domain or '-'} | Idade aparente: {e.apparent_age if e.apparent_age is not None else '-'}")
            hist.append(f"- Abraco: {e.embrace_year if e.embrace_year is not None else '-'} | Sire: {e.sire or '-'} | Acima do sire: -")
            hist.append(f"- Disciplinas (top 3): {e.disciplines_top3 or '-'}")
            hist.append(f"- Assinatura/estilo: {e.signature_style or '-'}")
            hist.append("")
            hist.append("Coteries/associacoes (com quem ele(a) anda, e quanto isso custa):")
            labs = coteries_labels(e)
            if labs:
                for nm in labs:
                    hist.append(f"- {nm}")
            else:
                hist.append("- (Sem grupo formal registrado)")
            hist.append("")
            hist.append("Tom (para narrar):")
            hist.append(tone_for_narration(e))
            hist.append("")
            hist.append("Historia (costurada, sem resumo seco):")
            if e.born_year and e.embrace_year:
                hist.append(
                    f"{e.display_name} nasceu em {e.born_year}. O Abraco veio em {e.embrace_year} e nao foi um 'presente': "
                    "foi uma decisao politica. Desde entao, a vida virou contabilidade de fome, nome e divida."
                )
            else:
                hist.append(
                    "O que se sabe (e o que importa em mesa): "
                    f"{e.display_name} opera como {e.role or 'agente'} em {e.domain or 'Sao Paulo'}, "
                    "tem aliados e inimigos identificaveis, e a sua estabilidade depende de protocolo e de fome. "
                    "O passado entra em jogo quando alguem cobra um favor antigo, aponta uma contradicao, "
                    "ou usa um erro de Mascara como arma politica."
                )
            if e.ambition or e.fear:
                hist.append(
                    f"A ambicao e direta: {e.ambition or '-'} "
                    f"O medo e igualmente pratico: {e.fear or '-'}"
                )
            hist.append("")
            hist.append("Atuacao na sociedade mortal (explicita, pratica):")
            for m in default_mortal_footprint(e):
                hist.append(f"- {m}")
            hist.append("")
            hist.append("Segredo (objetivamente jogavel):")
            if e.secret:
                hist.append(f"- {e.secret}")
            else:
                hist.append("- (Nao definido)")
            hist.append("")
            hist.append("Rumor e verdade (municao social):")
            if e.false_rumor:
                hist.append(f"- Rumor (falso): {e.false_rumor}")
            if e.dangerous_truth:
                hist.append(f"- Verdade (perigosa): {e.dangerous_truth}")
            if not e.false_rumor and not e.dangerous_truth:
                hist.append("- (Nao definido)")
            hist.append("")
            hist.append("Conexoes (com motivo e custo):")
            if e.links:
                for l in e.links:
                    hist.append(format_links_line(by_id, l))
            else:
                hist.append("- (Sem conexoes registradas)")
            servants = servants_by_master.get(e.id) or []
            hist.append("")
            hist.append("Ghouls/servos diretos (quem carrega recados, chaves e risco por voce):")
            if servants:
                for sx in sorted(servants, key=lambda z: z.display_name or ""):
                    hist.append(f"- {sx.display_name}: {sx.role or 'ghoul'} (area: {sx.domain or '-'})")
            else:
                hist.append("- (Nenhum servo direto registrado)")
            if e.childer:
                hist.append("")
                hist.append("Linhagem (quem carrega seu sangue e seu problema):")
                for c in e.childer:
                    hist.append(f"- {c}")
            hist.append("")
            hist.append("Cenas prontas (para jogar hoje):")
            if e.scene_hooks:
                for h in e.scene_hooks[:3]:
                    hist.append(f"- Cena: {e.domain or 'Sao Paulo'}. {h}")
            else:
                hist.append(f"- Cena: {e.domain or 'Sao Paulo'}. Um encontro pequeno vira custo grande.")

            write_text(out_dir / f"{stem}_historia.txt", "\n".join(hist).rstrip() + "\n", overwrite=overwrite)

            # Full sheet (if provided)
            if e.full_sheet:
                write_text(out_dir / f"{stem}_ficha_completa.md", e.full_sheet.rstrip() + "\n", overwrite=overwrite)

        else:
            # Ghoul/mortal/other
            ficha = []
            ficha.append(f"Nome: {e.display_name}")
            ficha.append(f"Tipo: {e.kind}")
            if e.sect:
                ficha.append(f"Vinculo: {e.sect}")
            if e.role:
                ficha.append(f"Papel: {e.role}")
            if e.domain:
                ficha.append(f"Area: {e.domain}")
            if e.signature_style:
                ficha.append(f"Assinatura / estilo: {e.signature_style}")
            labs = coteries_labels(e)
            if labs:
                ficha.append("Coteries/associacoes:")
                for nm in labs[:6]:
                    ficha.append(f"- {nm}")
            write_text(out_dir / f"{stem}_ficha_resumida.txt", "\n".join(ficha).rstrip() + "\n", overwrite=overwrite)

            hist = []
            hist.append(e.display_name)
            hist.append("")
            hist.append("Perfil:")
            hist.append(f"- Tipo: {e.kind} | Vinculo: {e.sect or '-'} | Papel: {e.role or '-'}")
            hist.append(f"- Area: {e.domain or '-'}")
            if e.signature_style:
                hist.append(f"- Assinatura/estilo: {e.signature_style}")
            labs = coteries_labels(e)
            if labs:
                hist.append("")
                hist.append("Coteries/associacoes:")
                for nm in labs[:10]:
                    hist.append(f"- {nm}")
            hist.append("")
            hist.append("Tom (para narrar):")
            hist.append(tone_for_non_kindred(e))
            hist.append("")
            hist.append("Historia (costurada, sem resumo seco):")
            hist.append(
                f"{e.display_name} vive no ponto em que o mundo mortal toca o tabuleiro cainita: {e.role or 'contato'}. "
                f"A area operacional e {e.domain or 'Sao Paulo'}. O que importa em cena: um pedido 'pequeno' aqui vira cadeia de favores."
            )
            if e.ambition or e.fear:
                hist.append(f"A ambicao e: {e.ambition or '-'}. O medo e: {e.fear or '-'}.")
            hist.append("")
            hist.append("Atuacao na sociedade mortal (explicita, pratica):")
            for m in default_mortal_footprint(e):
                hist.append(f"- {m}")
            hist.append("")
            hist.append("Segredo (objetivamente jogavel):")
            hist.append(f"- {e.secret or '(Nao definido)'}")
            hist.append("")
            hist.append("Conexoes (com motivo e custo):")
            if e.links:
                for l in e.links:
                    hist.append(format_links_line(by_id, l))
            else:
                hist.append("- (Sem conexoes registradas)")
            hist.append("")
            hist.append("Cenas prontas (para jogar hoje):")
            if e.scene_hooks:
                for h in e.scene_hooks[:3]:
                    hist.append(f"- Cena: {e.domain or 'Sao Paulo'}. {h}")
            else:
                hist.append("- Cena: um contato some e vira alavanca politica.")

            write_text(out_dir / f"{stem}_historia.txt", "\n".join(hist).rstrip() + "\n", overwrite=overwrite)


def write_geopolitics_md(entities: List[Entity], overwrite: bool) -> None:
    cfg_path = ROOT / "tools" / "sp_map_config.json"
    if not cfg_path.exists():
        return
    cfg = read_json(cfg_path)
    zones = list(cfg.get("geo_zones", []))
    domains = list(cfg.get("domains", []))

    claims_path = ROOT / "tools" / "sp_district_claims.json"
    claims = read_json(claims_path) if claims_path.exists() else {}
    dominant = claims.get("dominant", {}) if isinstance(claims, dict) else {}
    disputes = claims.get("disputes", {}) if isinstance(claims, dict) else {}

    dd_path = ROOT / "tools" / "sp_domain_districts.json"
    domain_districts = read_json(dd_path).get("domain_districts", {}) if dd_path.exists() else {}

    def norm(s: str) -> str:
        return (s or "").strip().lower()

    domain_keywords = {d["id"]: [norm(k) for k in d.get("keywords", []) if norm(k)] for d in domains}
    npc_to_domain_ids: Dict[str, List[str]] = {}
    for e in entities:
        if e.kind != "kindred":
            continue
        ed = norm(e.domain)
        if not ed:
            continue
        hits: List[str] = []
        for did, keys in domain_keywords.items():
            for k in keys:
                if k and k in ed:
                    hits.append(did)
                    break
        if hits:
            npc_to_domain_ids[e.id] = sorted(set(hits))

    factions = sorted(
        set([z.get("faction", "") for z in zones if z.get("faction")] + [d.get("faction", "") for d in domains if d.get("faction")]),
        key=lambda x: x.lower(),
    )

    def districts_dominant_for_faction(f: str) -> List[str]:
        out = [d for d, fac in dominant.items() if fac == f]
        return sorted(out, key=lambda x: x.lower())

    def disputes_for_faction(f: str) -> List[Tuple[str, Dict[str, Any]]]:
        out: List[Tuple[str, Dict[str, Any]]] = []
        for d, meta in (disputes or {}).items():
            between = (meta or {}).get("between", [])
            if isinstance(between, list) and f in between:
                out.append((d, meta))
        return sorted(out, key=lambda x: x[0].lower())

    lines: List[str] = []
    lines.append("# Geopolitica Territorial (Sao Paulo by Night)")
    lines.append("")
    lines.append("Este arquivo costura o que existe no mapa `06_MAPA_SP/mapa_sp_dominios.html` em texto jogavel.")
    lines.append("Delimitacoes sao jogaveis, nao juridicas: em mesa, territorio e sempre horario, evento e camera.")
    lines.append("")
    lines.append("Nota de mapa (importante):")
    lines.append("- A camada principal usa **distritos oficiais** (poligonos) para controle e disputa.")
    lines.append("- As 'zonas' e alguns 'dominios' antigos como circulos sao **aproximacoes** (bom para encontros e foco), e nao fronteiras duras.")
    lines.append("")

    for f in factions:
        lines.append(f"## {f}")
        lines.append("")

        ddom = districts_dominant_for_faction(f)
        if ddom:
            lines.append("Controle por distrito (camada real):")
            lines.append("- Distritos dominantes: " + ", ".join(ddom) + ".")
            fdisp = disputes_for_faction(f)
            if fdisp:
                lines.append("- Disputas notaveis:")
                for dname, meta in fdisp[:12]:
                    between = (meta or {}).get("between", [])
                    note = (meta or {}).get("note", "")
                    bt = " vs ".join(between) if isinstance(between, list) else "-"
                    tail = (" " + note) if note else ""
                    lines.append(f"  - {dname}: {bt}.{tail}".rstrip())
            lines.append("")

        zlist = [z for z in zones if z.get("faction") == f]
        if zlist:
            lines.append("Zonas (visao geral):")
            for z in zlist:
                lines.append(f"- {z.get('name','-')}: {z.get('notes','-')}")
            lines.append("")

        dlist = [d for d in domains if d.get("faction") == f]
        if dlist:
            lines.append("Territorios (divisoes jogaveis):")
            for d in dlist:
                did = d.get("id", "")
                ds = domain_districts.get(did) or []
                if isinstance(ds, list) and ds:
                    lines.append(f"- {d.get('name','-')}: distritos = {', '.join(ds)}.")
                else:
                    lines.append(f"- {d.get('name','-')}: raio ~{d.get('radius_m','-')}m (aprox.).")
                who = []
                for e in entities:
                    if e.kind != "kindred":
                        continue
                    if did in npc_to_domain_ids.get(e.id, []):
                        who.append(f"{e.display_name} ({e.clan}; {e.role or '-'})")
                who = sorted(who)[:10]
                if who:
                    lines.append("  NPCs que operam aqui:")
                    for w in who:
                        lines.append(f"  - {w}")
            lines.append("")

        if not zlist and not dlist and not ddom:
            lines.append("- (Sem camada territorial definida ainda; use como zona de transicao ou disputa.)")
            lines.append("")

    write_text(ROOT / "01_BACKGROUND_NARRADOR" / "geopolitica_territorial.md", "\n".join(lines).rstrip() + "\n", overwrite=overwrite)


def write_map_html(entities: List[Entity], overwrite: bool) -> None:
    out_path = ROOT / "06_MAPA_SP" / "mapa_sp_dominios.html"
    cfg_path = ROOT / "tools" / "sp_map_config.json"
    if not cfg_path.exists():
        return
    cfg = read_json(cfg_path)

    claims_path = ROOT / "tools" / "sp_district_claims.json"
    district_claims = read_json(claims_path) if claims_path.exists() else {}

    macro_path = ROOT / "tools" / "sp_macro_territories.json"
    macro_territories = read_json(macro_path) if macro_path.exists() else {}

    residence_path = ROOT / "tools" / "sp_kindred_residence.json"
    residence = read_json(residence_path).get("residence", {}) if residence_path.exists() else {}

    dd_path = ROOT / "tools" / "sp_domain_districts.json"
    domain_districts = read_json(dd_path).get("domain_districts", {}) if dd_path.exists() else {}

    owners_path = ROOT / "tools" / "sp_domain_owners.json"
    domain_owners = read_json(owners_path).get("owners", {}) if owners_path.exists() else {}
    coteries_by_id = load_coteries_index()

    districts_geo_path = ROOT / "06_MAPA_SP" / "data" / "distritos-sp.geojson"
    districts_geo = read_json(districts_geo_path) if districts_geo_path.exists() else {"type": "FeatureCollection", "features": []}

    # Build Kindred -> domain ids by keyword match.
    def norm(s: str) -> str:
        return (s or "").strip().lower()

    domains = list(cfg.get("domains", []))
    domain_keywords = {d["id"]: [norm(k) for k in d.get("keywords", []) if norm(k)] for d in domains}
    kindred_to_domain_ids: Dict[str, List[str]] = {}
    for e in entities:
        if e.kind != "kindred":
            continue
        ed = norm(e.domain)
        hits: List[str] = []
        for did, keys in domain_keywords.items():
            for k in keys:
                if k and k in ed:
                    hits.append(did)
                    break
        if hits:
            kindred_to_domain_ids[e.id] = sorted(set(hits))

    # Map payload: all Kindred (for dropdown "todos os vampiros").
    kindred_payload: List[Dict[str, Any]] = []
    for e in entities:
        if e.kind != "kindred":
            continue
        dids = kindred_to_domain_ids.get(e.id, [])
        # Relative path from 06_MAPA_SP/mapa_sp_dominios.html to 02_NPCS/<Clan>/<stem>.png
        portrait_path = f"../02_NPCS/{clan_folder(e.clan)}/{e.file_stem}.png" if e.file_stem else ""
        kindred_payload.append(
            {
                "id": e.id,
                "name": e.display_name,
                "file_stem": e.file_stem,
                "portrait_path": portrait_path,
                "clan": e.clan,
                "sect": e.sect,
                "role": e.role,
                "tier": e.tier,
                "domain_raw": e.domain,
                "map_domains": dids,
                "residence_id": (residence.get(e.id) or {}).get("residence_id", ""),
                "residence_label": (residence.get(e.id) or {}).get("residence_label", ""),
                "appearance_explicit": e.appearance_explicit,
                "mortal_footprint": default_mortal_footprint(e),
                "coteries": list(e.coteries or []),
            }
        )
    kindred_payload.sort(key=lambda x: (x.get("sect") or "", x.get("tier") != "S", x.get("clan") or "", x.get("name") or ""))

    payload = {
        "meta": cfg.get("meta", {}),
        "domains": list(cfg.get("domains", [])),
        "pois": list(cfg.get("pois", [])),
        "district_claims": district_claims,
        "macro_territories": macro_territories,
        "domain_districts": domain_districts,
        "domain_owners": domain_owners,
        "kindred": kindred_payload,
        "coteries": list(coteries_by_id.values()),
    }
    data_json = json.dumps(payload, ensure_ascii=False)
    districts_json = json.dumps(districts_geo, ensure_ascii=False)

    # Always write a full interactive HTML (no more fragile "patch in place").
    leaflet_js_path = ROOT / "05_ASSETS" / "vendor" / "leaflet" / "leaflet.js"
    leaflet_css_path = ROOT / "05_ASSETS" / "vendor" / "leaflet" / "leaflet.css"
    if not leaflet_js_path.exists() or not leaflet_css_path.exists():
        die("missing Leaflet vendor assets in 05_ASSETS/vendor/leaflet (leaflet.js, leaflet.css)")
    leaflet_js = leaflet_js_path.read_text(encoding="utf-8")
    leaflet_css = leaflet_css_path.read_text(encoding="utf-8")

    html = f"""<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sao Paulo by Night - Mapa Territorial</title>
  <style>
  {leaflet_css}
  :root {{
    --bg: #0e1116;
    --panel: #121825;
    --panel2: #0b0f16;
    --text: #eef1f7;
    --muted: rgba(238,241,247,0.72);
    --border: rgba(238,241,247,0.14);
    --shadow: rgba(0,0,0,0.45);
  }}
  html, body {{ height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }}
  .app {{ display: grid; grid-template-columns: 410px 1fr; height: 100%; }}
  .sidebar {{ background: linear-gradient(180deg, var(--panel), var(--panel2)); border-right: 1px solid var(--border); display:flex; flex-direction: column; }}
  header {{ padding: 14px 14px 10px 14px; border-bottom: 1px solid var(--border); }}
  h1 {{ margin: 0 0 6px 0; font-size: 16px; font-weight: 800; letter-spacing: 0.3px; }}
  .small {{ font-size: 12px; color: var(--muted); line-height: 1.35; }}
  .controls {{ padding: 12px 14px; border-bottom: 1px solid var(--border); }}
  .checks {{ display:flex; flex-wrap: wrap; gap: 8px; }}
  .checks label {{
    display:flex; align-items:center; gap: 8px;
    font-size: 12px; color: rgba(238,241,247,0.92);
    padding: 8px 10px; border: 1px solid rgba(238,241,247,0.16); border-radius: 999px;
    background: rgba(255,255,255,0.04);
    user-select: none;
  }}
  .checks input[type="checkbox"] {{ width: 16px; height: 16px; }}
  .row {{ margin-top: 10px; }}
  .row label {{ display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }}
  select {{
    width: 100%;
    background: #f2f2f2;
    color: #111111;
    border: 1px solid rgba(0,0,0,0.22);
    border-radius: 10px;
    padding: 10px 10px;
    font-size: 13px;
    outline: none;
  }}
  button {{
    background: rgba(255,255,255,0.06);
    color: rgba(238,241,247,0.92);
    border: 1px solid rgba(238,241,247,0.16);
    border-radius: 10px;
    padding: 10px 10px;
    font-size: 13px;
    cursor: pointer;
  }}
  button:hover {{ border-color: rgba(238,241,247,0.26); }}
  .buttons {{ display:flex; gap: 8px; }}
  .buttons button {{ width: 33.33%; }}
  #map {{ height: 100%; }}
  .panel {{ padding: 12px 14px; overflow: auto; flex: 1; }}
  .panelTitle {{ font-size: 14px; font-weight: 800; margin-bottom: 8px; }}
  .status {{ font-size: 12px; color: var(--muted); margin-top: 10px; line-height: 1.35; }}
  .portrait {{
    display:flex; gap: 12px; align-items: center;
    padding: 10px; border: 1px solid rgba(238,241,247,0.14); border-radius: 12px;
    background: rgba(255,255,255,0.03);
    box-shadow: 0 12px 32px var(--shadow);
    margin: 10px 0;
  }}
  .portrait img {{ width: 88px; height: 88px; border-radius: 12px; object-fit: cover; border: 1px solid rgba(238,241,247,0.18); display:none; background: rgba(0,0,0,0.20); }}
  .portrait .cap {{ font-size: 12px; color: rgba(238,241,247,0.78); line-height: 1.35; }}
  .details {{
    font-size: 12px;
    line-height: 1.45;
    color: rgba(238,241,247,0.92);
    white-space: pre-wrap;
    border: 1px solid rgba(238,241,247,0.14);
    border-radius: 12px;
    padding: 10px;
    background: rgba(0,0,0,0.22);
    box-shadow: 0 12px 32px var(--shadow);
  }}
  .leaflet-container {{ background: #0b0e13; }}
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <header>
        <h1>Sao Paulo by Night: Mapa Territorial</h1>
        <div class="small">Camadas por distritos. Clique em overlays para ver dono/descricao. Selecione dominios Camarilla (territorios expressivos) ou qualquer Cainita para ver local aproximado e retrato (se existir).</div>
      </header>

      <div class="controls">
        <div class="checks">
          <label><input type="checkbox" id="cbCamarilla" /> Camarilla (macro)</label>
          <label><input type="checkbox" id="cbAnarch" /> Anarch (baronatos)</label>
          <label><input type="checkbox" id="cbIndep" /> Independentes</label>
          <label><input type="checkbox" id="cbLupino" /> Risco lupino</label>
          <label><input type="checkbox" id="cbPois" checked /> Pontos (pins)</label>
        </div>

        <div class="row">
          <label for="selCamarillaDomain">Dominios Camarilla (territorios expressivos)</label>
          <select id="selCamarillaDomain"></select>
        </div>

        <div class="row">
          <label for="selKindred">Todos os Cainitas (pins)</label>
          <select id="selKindred"></select>
        </div>

        <div class="row">
          <label for="selDistrict">Buscar por distrito (info local)</label>
          <select id="selDistrict"></select>
        </div>

        <div class="row">
          <div class="buttons">
            <button id="zoomIn">Zoom +</button>
            <button id="zoomOut">Zoom -</button>
            <button id="fitAll">Enquadrar</button>
          </div>
        </div>

        <div class="status" id="status"></div>
      </div>

      <div class="panel">
        <div class="panelTitle" id="panelTitle">Selecione uma camada, dominio ou Cainita</div>
        <div class="portrait">
          <img id="portraitImg" alt="" />
          <div class="cap" id="portraitCap">Se existir uma imagem PNG com o mesmo nome do NPC, ela aparece aqui.</div>
        </div>
        <div class="details" id="panelDetails">Dica: marque Camarilla/Anarch/Independentes para ver a geopolitica macro. Territorios contestados aparecem quando qualquer lado do conflito esta marcado.</div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
{leaflet_js}
  const DATA = {data_json};
  const DISTRICTS_GEOJSON = {districts_json};

  function el(id) {{ return document.getElementById(id); }}
  function dk(s) {{ return (s || '').toUpperCase().trim(); }}
  function setTitle(t) {{ el('panelTitle').textContent = t || ''; }}
  function setStatus(t) {{ el('status').textContent = t || ''; }}
  function setDetails(lines) {{
    el('panelDetails').textContent = Array.isArray(lines) ? lines.join('\\n') : (lines || '');
  }}
  function setPortrait(src, caption) {{
    const img = el('portraitImg');
    const cap = el('portraitCap');
    cap.textContent = caption || '';
    if (!src) {{
      img.style.display = 'none';
      img.src = '';
      return;
    }}
    img.onerror = () => {{ img.style.display = 'none'; }};
    img.onload = () => {{ img.style.display = 'block'; }};
    img.src = src;
  }}

  // Color palette: strong hues + strong outlines (dalt?nico-friendly)
  const COLORS = {{
    Camarilla: '#f5c542',
    Anarch: '#ff7a00',
    Independentes: '#6f2dbd',
    Contestado: '#ff0033',
    Lupino: '#00b050',
    NeutralLine: 'rgba(238,241,247,0.34)',
  }};

  function macroKeyFromFactionName(f) {{
    f = (f || '').toLowerCase();
    if (f.includes('camar')) return 'Camarilla';
    if (f.includes('anarch')) return 'Anarch';
    if (f.includes('indep')) return 'Independentes';
    if (f.includes('autarqu') || f.includes('zona')) return 'Independentes';
    return f;
  }}

  const CLAIMS = (DATA.district_claims || {{}});
  const dominant = (CLAIMS.dominant || {{}});
  const disputes = (CLAIMS.disputes || {{}});
  const pressures = (CLAIMS.pressures || {{}});

  function districtDominant(name) {{ return dominant[dk(name)] || 'Camarilla'; }}
  function districtDispute(name) {{ return disputes[dk(name)] || null; }}
  function districtPressures(name) {{
    const v = pressures[dk(name)];
    return Array.isArray(v) ? v : [];
  }}

  // SVG renderer keeps pane z-index + hit-testing predictable for many overlapping polygons.
  const map = L.map('map', {{
    zoomControl: false,
    preferCanvas: false,
    wheelDebounceTime: 20,
    wheelPxPerZoomLevel: 90,
  }});
  map.setView([-23.5505, -46.6333], 11);

  L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }}).addTo(map);

  map.createPane('paneDistrictOutlines'); map.getPane('paneDistrictOutlines').style.zIndex = 250;
  map.createPane('paneMacro'); map.getPane('paneMacro').style.zIndex = 320;
  map.createPane('paneContested'); map.getPane('paneContested').style.zIndex = 360;
  map.createPane('paneDomains'); map.getPane('paneDomains').style.zIndex = 380;
  map.createPane('panePins'); map.getPane('panePins').style.zIndex = 420;

  // One SVG renderer per pane to avoid "everything shares one canvas" ambiguity.
  const RENDERERS = {{
    paneDistrictOutlines: L.svg({{ pane: 'paneDistrictOutlines' }}),
    paneMacro: L.svg({{ pane: 'paneMacro' }}),
    paneContested: L.svg({{ pane: 'paneContested' }}),
    paneDomains: L.svg({{ pane: 'paneDomains' }}),
    panePins: L.svg({{ pane: 'panePins' }}),
  }};
  function rendererForPane(paneId) {{
    return RENDERERS[paneId] || RENDERERS.paneMacro;
  }}

  function layerFromDistricts(districts, paneId, styleFn, onClick) {{
    const wanted = new Set((districts || []).map(dk));
    return L.geoJSON(DISTRICTS_GEOJSON, {{
      pane: paneId || 'paneMacro',
      renderer: rendererForPane(paneId || 'paneMacro'),
      interactive: true,
      bubblingMouseEvents: false,
      filter: (feature) => {{
        const name = feature && feature.properties ? feature.properties.ds_nome : '';
        return wanted.has(dk(name));
      }},
      style: (feature) => {{
        const name = feature && feature.properties ? feature.properties.ds_nome : '';
        return styleFn ? styleFn(name, feature) : {{}};
      }},
      onEachFeature: (feature, layer) => {{
        if (!onClick) return;
        layer.on('click', (ev) => {{
          // Prevent district outlines (and other layers) from stealing the click.
          try {{
            if (ev && ev.originalEvent) {{
              ev.originalEvent._spbn_overlay_click = true;
              L.DomEvent.stop(ev.originalEvent);
            }}
          }} catch (e) {{}}
          onClick(feature, layer, ev);
        }});
      }},
    }});
  }}

  // Base district outlines (always visible, neutral)
  let lastDistrict = null;
  const districtOutlines = L.geoJSON(DISTRICTS_GEOJSON, {{
    pane: 'paneDistrictOutlines',
    renderer: rendererForPane('paneDistrictOutlines'),
    style: () => ({{
      color: COLORS.NeutralLine,
      weight: 1,
      fillOpacity: 0.0,
    }}),
    onEachFeature: (feature, layer) => {{
      const name = feature && feature.properties ? feature.properties.ds_nome : '';
      layer.bindTooltip(name, {{ sticky: true, opacity: 0.94 }});
      layer.on('click', (ev) => {{
        // If an overlay handled this click, do not overwrite the side panel with "Distrito".
        try {{
          if (ev && ev.originalEvent && ev.originalEvent._spbn_overlay_click) return;
        }} catch(e) {{}}
        if (lastDistrict) {{
          try {{ districtOutlines.resetStyle(lastDistrict); }} catch(e) {{}}
        }}
        lastDistrict = layer;
        layer.setStyle({{ color: '#ffffff', weight: 3 }});
        const dom = districtDominant(name);
        const ds = districtDispute(name);
        const pr = districtPressures(name);
        const lines = [];
        lines.push('Distrito: ' + name);
        lines.push('Controle local (claims): ' + dom);
        if (ds) {{
          lines.push('');
          lines.push('Disputa: ' + (ds.between || []).join(' vs '));
          if (ds.note) lines.push(ds.note);
        }}
        if (pr && pr.length) {{
          lines.push('');
          lines.push('Alertas:');
          pr.forEach(x => lines.push('- ' + x));
        }}
        setTitle('Distrito: ' + name);
        setPortrait('', '');
        setDetails(lines);
      }});
    }},
  }}).addTo(map);

  // POIs (pins)
  const poiGroup = L.layerGroup();
  function poiIcon(kind) {{
    const k = (kind || 'poi').toLowerCase();
    const bg = '#111111';
    const ring = k === 'elysium' ? COLORS.Camarilla : (k === 'hecata' ? COLORS.Independentes : '#00c2ff');
    return L.divIcon({{
      className: '',
      html: `<div style="width:14px;height:14px;border-radius:14px;background:${{bg}};border:3px solid ${{ring}};box-shadow:0 4px 14px rgba(0,0,0,0.45)"></div>`,
      iconSize:[14,14],
      iconAnchor:[7,7],
    }});
  }}
  (DATA.pois || []).forEach(p => {{
    if (!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return;
    const m = L.marker([p.lat, p.lon], {{ pane: 'panePins', icon: poiIcon(p.kind) }});
    m.on('click', () => {{
      const lines = [];
      lines.push('Ponto: ' + p.name);
      lines.push('Tipo: ' + (p.kind || 'poi'));
      if (p.domain_id) lines.push('Relacionado a dominio: ' + p.domain_id);
      if (p.notes) {{
        lines.push('');
        lines.push('Descricao:');
        lines.push(String(p.notes));
      }}
      setTitle('Ponto: ' + p.name);
      setPortrait('', '');
      setDetails(lines);
      try {{ map.setView(m.getLatLng(), Math.max(map.getZoom(), 14), {{ animate:true }}); }} catch(e) {{}}
    }});
    poiGroup.addLayer(m);
  }});

  // Domains (district-polygons)
  const DOMAIN_DISTRICTS = (DATA.domain_districts || {{}});
  const domainMeta = new Map((DATA.domains || []).map(d => [d.id, d]));
  const domainOwners = (DATA.domain_owners || {{}});
  const domainLayers = new Map();
  Object.keys(DOMAIN_DISTRICTS || {{}}).forEach(did => {{
    const ds = DOMAIN_DISTRICTS[did] || [];
    if (!Array.isArray(ds) || !ds.length) return;
    const d = domainMeta.get(did) || {{}};
    const col = (d.faction && macroKeyFromFactionName(d.faction) === 'Camarilla') ? COLORS.Camarilla : '#00c2ff';
    const layer = layerFromDistricts(ds, 'paneDomains', () => ({{
      color: '#ffffff',
      weight: 2,
      dashArray: '4 8',
      fillColor: col,
      fillOpacity: 0.0,
    }}));
    domainLayers.set(did, layer);
  }});

  // Subdivisoes Camarilla (territorios expressivos) visiveis quando o checkbox Camarilla (macro) esta marcado.
  // Clique em um territorio aqui = selecionar automaticamente o dominio no dropdown (modo "lordes").
  const camarillaLordLayers = new Map();
  (DATA.domains || []).forEach(d => {{
    if (macroKeyFromFactionName(d.faction) !== 'Camarilla') return;
    const owner = domainOwners[d.id];
    if (!owner || !(owner.label || owner.owner_entity_id)) return;
    const ds = DOMAIN_DISTRICTS[d.id] || [];
    if (!Array.isArray(ds) || !ds.length) return;
    const lay = layerFromDistricts(ds, 'paneDomains', () => ({{
      color: '#111111',
      weight: 2,
      dashArray: '1 7',
      fillColor: COLORS.Camarilla,
      fillOpacity: 0.18,
    }}), () => {{
      const sel = el('selCamarillaDomain');
      sel.value = d.id;
      sel.dispatchEvent(new Event('change'));
    }});
    camarillaLordLayers.set(d.id, lay);
  }});

  let domainPin = null;
  function clearDomain() {{
    domainLayers.forEach(l => {{ try {{ map.removeLayer(l); }} catch(e) {{}} }});
    if (domainPin) {{ try {{ map.removeLayer(domainPin); }} catch(e) {{}} domainPin = null; }}
  }}

  function showDomain(did, emphasizeColor) {{
    clearDomain();
    if (!did) return;
    const layer = domainLayers.get(did);
    if (layer) {{
      layer.setStyle({{
        pane: 'paneDomains',
        color: '#111111',
        weight: 4,
        dashArray: '0',
        fillColor: emphasizeColor || COLORS.Camarilla,
        fillOpacity: 0.34,
      }});
      layer.addTo(map);
      try {{ map.fitBounds(layer.getBounds().pad(0.20), {{ animate:true, maxZoom: 14 }}); }} catch(e) {{}}
    }}
    const d = domainMeta.get(did) || null;
    if (d && d.center && Number.isFinite(d.center.lat) && Number.isFinite(d.center.lon)) {{
      domainPin = L.circleMarker([d.center.lat, d.center.lon], {{
        pane: 'panePins',
        radius: 7,
        color: '#111111',
        weight: 3,
        fillColor: emphasizeColor || COLORS.Camarilla,
        fillOpacity: 0.9,
      }}).addTo(map);
    }}
  }}

  // Macro territories
  const MT = (DATA.macro_territories || {{}});
  const camMacro = (MT.macro || [])[0] || null;
  const anarchBaronatos = (MT.anarch_baronatos || []);
  const independentes = (MT.independentes || []);
  const contested = (MT.contested || []);
  const alerts = (MT.alerts || []);

  const kindredList = (DATA.kindred || []);

  function setMacroInfo(meta, titlePrefix) {{
    const lines = [];
    lines.push((titlePrefix || 'Territorio') + ': ' + (meta.label || meta.id || ''));
    lines.push('Faccao/camada: ' + (meta.faction || '-'));
    if (meta.leader_label) lines.push('Responsavel: ' + meta.leader_label);
    if (Array.isArray(meta.districts) && meta.districts.length) lines.push('Distritos: ' + meta.districts.join(', '));
    if (Array.isArray(meta.between) && meta.between.length) lines.push('Disputa: ' + meta.between.join(' vs '));

    // Macro totals (coherent with "o que existe no projeto", nao com a cidade inteira real).
    const sectKey = macroKeyFromFactionName(meta.faction || '');
    if ((meta.id || '') === 'camarilla_macro') {{
      const camTotal = kindredList.filter(k => macroKeyFromFactionName(k.sect) === 'Camarilla').length;
      const prince = kindredList.find(k => (k.role || '').toLowerCase().includes('principe'));
      const sheriff = kindredList.find(k => (k.role || '').toLowerCase().includes('xerife'));
      const seneschal = kindredList.find(k => (k.role || '').toLowerCase().includes('senescal'));
      const harpies = kindredList.filter(k => (k.role || '').toLowerCase().includes('harpia'));
      lines.push('Camarilla reconhecida no projeto (total): ' + camTotal);
      if (prince) lines.push('Principe: ' + prince.name);
      if (seneschal) lines.push('Senescal: ' + seneschal.name);
      if (sheriff) lines.push('Xerife: ' + sheriff.name);
      if (harpies.length) lines.push('Harpias: ' + harpies.map(h => h.name).join(', '));
    }} else if (sectKey === 'Anarch') {{
      const aTotal = kindredList.filter(k => macroKeyFromFactionName(k.sect) === 'Anarch').length;
      lines.push('Anarch no projeto (total): ' + aTotal);
    }} else if (sectKey === 'Independentes') {{
      const iTotal = kindredList.filter(k => macroKeyFromFactionName(k.sect) === 'Independentes').length;
      lines.push('Independentes no projeto (total): ' + iTotal);
    }}

    const wanted = new Set((meta.districts || []).map(dk));
    const operatives = kindredList.filter(k => {{
      const dids = (k.map_domains || []);
      for (const did of dids) {{
        const dd = DOMAIN_DISTRICTS[did] || [];
        for (const d of dd) if (wanted.has(dk(d))) return true;
      }}
      return false;
    }});

    const residents = kindredList.filter(k => (k.residence_id || '') === (meta.id || ''));

    lines.push('Cainitas residentes conhecidos (cronica): ' + residents.length);
    lines.push('Cainitas que operam aqui (por dominio/presenca no mapa): ' + operatives.length);

    if (residents.length) {{
      lines.push('');
      lines.push('Residentes:');
      residents
        .slice()
        .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')))
        .slice(0, 24)
        .forEach(k => lines.push('- ' + k.name + ' (' + k.clan + '; ' + (k.role || '-') + ')'));
      if (residents.length > 24) lines.push('- ...');
    }}
    if (operatives.length) {{
      lines.push('');
      lines.push('Operam aqui:');
      operatives
        .slice()
        .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')))
        .slice(0, 24)
        .forEach(k => lines.push('- ' + k.name + ' (' + k.clan + '; ' + (k.role || '-') + ')'));
      if (operatives.length > 24) lines.push('- ...');
    }}

    if (meta.notes) {{
      lines.push('');
      lines.push('Descricao:');
      lines.push(String(meta.notes));
    }}
    setPortrait('', '');
    setDetails(lines);
  }}

  const layerCamarilla = camMacro ? layerFromDistricts(camMacro.districts, 'paneMacro', () => ({{
    pane: 'paneMacro',
    color: '#111111',
    weight: 2,
    fillColor: COLORS.Camarilla,
    fillOpacity: 0.12,
  }}), () => {{
    setTitle('Camarilla (macro)');
    setMacroInfo(camMacro, 'Macro');
  }}) : null;

  const anarchLayers = new Map();
  anarchBaronatos.forEach(b => {{
    const lay = layerFromDistricts(b.districts, 'paneMacro', () => ({{
      pane: 'paneMacro',
      color: '#111111',
      weight: 3,
      fillColor: COLORS.Anarch,
      fillOpacity: 0.34,
    }}), () => {{
      setTitle(b.label || 'Baronato');
      setMacroInfo(b, 'Baronato');
    }});
    anarchLayers.set(b.id, lay);
  }});

  const indepLayers = new Map();
  independentes.forEach(b => {{
    const lay = layerFromDistricts(b.districts, 'paneMacro', () => ({{
      pane: 'paneMacro',
      color: '#111111',
      weight: 3,
      fillColor: COLORS.Independentes,
      fillOpacity: 0.34,
    }}), () => {{
      setTitle(b.label || 'Independentes');
      setMacroInfo(b, 'Bloco');
    }});
    indepLayers.set(b.id, lay);
  }});

  let lupDistricts = [];
  alerts.forEach(a => {{ if ((a.id || '') === 'risco_lupino') lupDistricts = a.districts || []; }});
  const layerLupino = layerFromDistricts(lupDistricts, 'paneMacro', () => ({{
    pane: 'paneMacro',
    color: '#111111',
    weight: 3,
    dashArray: '2 8',
    fillColor: COLORS.Lupino,
    fillOpacity: 0.20,
  }}), () => {{
    const a = alerts.find(x => (x.id || '') === 'risco_lupino') || {{ label:'Risco lupino', faction:'Risco lupino', districts:lupDistricts }};
    setTitle('Risco lupino (alerta)');
    setMacroInfo(a, 'Alerta');
  }});

  const contestedLayers = [];
  contested.forEach(c => {{
    const lay = layerFromDistricts(c.districts, 'paneContested', () => ({{
      pane: 'paneContested',
      color: '#111111',
      weight: 4,
      dashArray: '8 6',
      fillColor: COLORS.Contestado,
      fillOpacity: 0.30,
    }}), () => {{
      setTitle(c.label || 'Territorio contestado');
      setMacroInfo(c, 'Contestado');
    }});
    contestedLayers.push({{ meta: c, layer: lay }});
  }});

  function clearMacroLayers() {{
    if (layerCamarilla) map.removeLayer(layerCamarilla);
    camarillaLordLayers.forEach(l => map.removeLayer(l));
    anarchLayers.forEach(l => map.removeLayer(l));
    indepLayers.forEach(l => map.removeLayer(l));
    map.removeLayer(layerLupino);
    contestedLayers.forEach(x => map.removeLayer(x.layer));
  }}

  function anySideChecked(between) {{
    between = Array.isArray(between) ? between : [];
    const a = macroKeyFromFactionName(between[0] || '');
    const b = macroKeyFromFactionName(between[1] || '');
    const checked = {{
      Camarilla: el('cbCamarilla').checked,
      Anarch: el('cbAnarch').checked,
      Independentes: el('cbIndep').checked,
    }};
    return !!(checked[a] || checked[b]);
  }}

  function applyMacroVisibility() {{
    if (el('selCamarillaDomain').value) return;

    clearMacroLayers();
    if (el('cbCamarilla').checked && layerCamarilla) {{
      layerCamarilla.addTo(map);
      // Show Camarilla subdivisions (lordes) inside the macro watermark.
      camarillaLordLayers.forEach(l => l.addTo(map));
    }}
    if (el('cbAnarch').checked) anarchLayers.forEach(l => l.addTo(map));
    if (el('cbIndep').checked) indepLayers.forEach(l => l.addTo(map));
    if (el('cbLupino').checked) layerLupino.addTo(map);
    contestedLayers.forEach(x => {{ if (anySideChecked(x.meta.between)) x.layer.addTo(map); }});
  }}

  function fillSelect(select, items, placeholder) {{
    select.innerHTML = '';
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = placeholder;
    select.appendChild(opt0);
    items.forEach(it => {{
      const opt = document.createElement('option');
      opt.value = it.value;
      opt.textContent = it.label;
      select.appendChild(opt);
    }});
  }}

  const districtNames = (DISTRICTS_GEOJSON.features || [])
    .map(ft => ft && ft.properties ? ft.properties.ds_nome : '')
    .filter(Boolean)
    .sort((a,b)=>a.localeCompare(b));
  fillSelect(el('selDistrict'), districtNames.map(n => ({{ value:n, label:n }})), 'Selecione um distrito');

  fillSelect(el('selKindred'), kindredList.map(k => ({{ value:k.id, label: `${{k.name}} (${{k.clan}}; ${{k.sect || '-'}})` }})), 'Selecione um Cainita');

  const camDomainItems = (DATA.domains || [])
    .filter(d => macroKeyFromFactionName(d.faction) === 'Camarilla')
    .filter(d => (domainOwners[d.id] && (domainOwners[d.id].label || domainOwners[d.id].owner_entity_id)))
    .map(d => {{
      const o = domainOwners[d.id] || {{}};
      const ownerLabel = o.label ? ` - ${{o.label}}` : '';
      return {{ value: d.id, label: `${{d.name}}${{ownerLabel}}` }};
    }});
  fillSelect(el('selCamarillaDomain'), camDomainItems, 'Selecione um territorio Camarilla');

  el('selDistrict').addEventListener('change', () => {{
    const v = el('selDistrict').value;
    if (!v) return;
    districtOutlines.eachLayer(l => {{
      const n = (l.feature && l.feature.properties) ? l.feature.properties.ds_nome : '';
      if (dk(n) === dk(v)) {{
        l.fire('click');
        try {{ map.fitBounds(l.getBounds().pad(0.25), {{ animate:true, maxZoom: 14 }}); }} catch(e) {{}}
      }}
    }});
  }});

  el('selCamarillaDomain').addEventListener('change', () => {{
    const did = el('selCamarillaDomain').value;
    if (!did) {{
      clearDomain();
      applyMacroVisibility();
      return;
    }}

    el('cbCamarilla').checked = false;
    el('cbAnarch').checked = false;
    el('cbIndep').checked = false;
    el('cbLupino').checked = false;
    clearMacroLayers();

    showDomain(did, COLORS.Camarilla);
    const d = domainMeta.get(did) || {{}};
    const o = domainOwners[did] || null;
    const lines = [];
    lines.push('Territorio Camarilla: ' + (d.name || did));
    if (o && o.label) lines.push('Dono visivel: ' + o.label);
    const ds = DOMAIN_DISTRICTS[did] || [];
    if (ds.length) lines.push('Distritos: ' + ds.join(', '));
    const inHere = kindredList.filter(k => (k.map_domains || []).includes(did));
    lines.push('Cainitas do projeto associados a este territorio: ' + inHere.length);
    if (inHere.length) {{
      lines.push('');
      lines.push('Nomes:');
      inHere.slice(0, 18).forEach(k => lines.push('- ' + k.name + ' (' + k.clan + '; ' + (k.role || '-') + ')'));
      if (inHere.length > 18) lines.push('- ...');
    }}
    setTitle('Territorio: ' + (d.name || did));
    setPortrait('', '');
    setDetails(lines);
  }});

  let kindredPin = null;
  function setKindredPin(lat, lon, color) {{
    if (kindredPin) {{ try {{ map.removeLayer(kindredPin); }} catch(e) {{}} kindredPin = null; }}
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
    kindredPin = L.circleMarker([lat, lon], {{
      pane: 'panePins',
      radius: 8,
      color: '#111111',
      weight: 3,
      fillColor: color || '#00c2ff',
      fillOpacity: 0.95,
    }}).addTo(map);
  }}

  el('selKindred').addEventListener('change', () => {{
    const id = el('selKindred').value;
    const k = kindredList.find(x => x.id === id);
    if (!k) return;

    el('selCamarillaDomain').value = '';
    applyMacroVisibility();

    const did = (k.map_domains || [])[0] || '';
    if (did) showDomain(did, '#00c2ff'); else clearDomain();

    let lat = NaN, lon = NaN;
    if (did) {{
      const d = domainMeta.get(did);
      if (d && d.center) {{ lat = d.center.lat; lon = d.center.lon; }}
    }}
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {{
      const sect = macroKeyFromFactionName(k.sect);
      if (sect === 'Anarch') {{ lat = -23.5606808; lon = -46.5971924; }}
      else if (sect === 'Independentes') {{ lat = -23.5503898; lon = -46.633081; }}
      else {{ lat = -23.5560945; lon = -46.6622655; }}
    }}
    setKindredPin(lat, lon, '#00c2ff');
    try {{ map.setView([lat, lon], Math.max(map.getZoom(), 13), {{ animate:true }}); }} catch(e) {{}}

    const lines = [];
    lines.push('Cainita: ' + k.name);
    lines.push('Seita: ' + (k.sect || '-'));
    lines.push('Cla: ' + (k.clan || '-'));
    if (k.role) lines.push('Papel: ' + k.role);
    if (k.tier) lines.push('Tier: ' + k.tier);
    if (k.domain_raw) lines.push('Dominio (texto): ' + k.domain_raw);
    if (Array.isArray(k.coteries) && k.coteries.length) {{
      lines.push('');
      lines.push('Coteries/associacoes:');
      k.coteries.slice(0,8).forEach(cid => {{
        const meta = (DATA.coteries || []).find(x => x && x.id === cid) || null;
        const nm = meta ? (meta.name || cid) : cid;
        lines.push('- ' + nm);
      }});
      if (k.coteries.length > 8) lines.push('- ...');
    }}
    if (k.appearance_explicit) {{
      lines.push('');
      lines.push('Aparencia (para imagem):');
      lines.push(String(k.appearance_explicit));
    }}
    if (Array.isArray(k.mortal_footprint) && k.mortal_footprint.length) {{
      lines.push('');
      lines.push('Atuacao mortal:');
      k.mortal_footprint.slice(0,6).forEach(x => lines.push('- ' + x));
    }}
    setTitle(k.name + ' (' + k.clan + ')');
    setPortrait(k.portrait_path || '', 'Retrato: ' + k.name);
    setDetails(lines);
  }});

  ['cbCamarilla','cbAnarch','cbIndep','cbLupino'].forEach(id => el(id).addEventListener('change', applyMacroVisibility));
  el('cbPois').addEventListener('change', () => {{
    if (el('cbPois').checked) poiGroup.addTo(map); else poiGroup.removeFrom(map);
  }});

  el('zoomIn').addEventListener('click', () => map.zoomIn());
  el('zoomOut').addEventListener('click', () => map.zoomOut());
  el('fitAll').addEventListener('click', () => {{
    try {{ map.fitBounds(districtOutlines.getBounds().pad(0.05), {{ animate:true }}); }} catch(e) {{}}
  }});

  poiGroup.addTo(map);
  setStatus(
    'Como ler: marque uma faccao/camada para ver overlays macro por distrito. ' +
    'Territorios contestados aparecem quando qualquer lado do conflito esta marcado. ' +
    'Selecionar um territorio Camarilla desmarca as camadas macro e foca no territorio.'
  );
  applyMacroVisibility();
  setTimeout(() => {{ try {{ map.fitBounds(districtOutlines.getBounds().pad(0.05), {{ animate:true }}); }} catch(e) {{}} }}, 60);
  </script>
</body>
</html>
"""
    write_text(out_path, html, overwrite=overwrite)


def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--overwrite", action="store_true", help="overwrite existing files")
    ap.add_argument("--templates", action="store_true", help="copy tools/templates/** to output tree")
    ap.add_argument("--npcs", action="store_true", help="write NPC/ghoul/mortal files from tools/sp_by_night_source.json")
    ap.add_argument("--map", action="store_true", help="write 06_MAPA_SP/mapa_sp_dominios.html (updates DATA payload)")
    ap.add_argument("--geopolitics", action="store_true", help="write 01_BACKGROUND_NARRADOR/geopolitica_territorial.md")
    ap.add_argument("--all", action="store_true", help="run templates+npcs+map+geopolitics")
    args = ap.parse_args(argv)

    ents = load_entities()

    do_all = args.all or not (args.templates or args.npcs or args.map or args.geopolitics)
    if args.templates or do_all:
        apply_templates(overwrite=args.overwrite)
    if args.npcs or do_all:
        write_entity_files(ents, overwrite=args.overwrite)
    if args.map or do_all:
        write_map_html(ents, overwrite=args.overwrite)
        write_text(
            ROOT / "06_MAPA_SP" / "COMO_ABRIR_MAPA.txt",
            "Abra `06_MAPA_SP/mapa_sp_dominios.html`.\n\n"
            "Se o basemap ou os distritos nao carregarem, inicie um servidor local na raiz do projeto:\n"
            "- `python -m http.server 8010`\n"
            "Depois abra no navegador: `http://localhost:8010/06_MAPA_SP/mapa_sp_dominios.html`\n"
            "(Precisa internet para carregar tiles do OpenStreetMap.)\n",
            overwrite=args.overwrite,
        )
    if args.geopolitics or do_all:
        write_geopolitics_md(ents, overwrite=args.overwrite)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
